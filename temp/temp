依赖 use-a 表现：局部变量 静态引用 方法形参
关联 两个类彼此独立，平衡关系，表现：成员变量
组合 关联的一种，个体组装成主体，一个个体可以参与多个主体的组装，例如CPU 计算机
聚合 关联的一种，个体组装成主体，且只能组装成一种类型的主体，例如人和人脑
继承
实现

设计原则：
总原则：开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。

1、单一职责原则
不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。

2、里氏替换原则（Liskov Substitution Principle）
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。

3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。

4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

5、迪米特法则（最少知道原则）（Demeter Principle）
就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。

最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。

6、合成复用原则（Composite Reuse Principle）
原则是尽量首先使用合成/聚合的方式，而不是使用继承。


创建型模式，共五种：
工厂方法模式：
表现：父类定义抽象创建对象的方法，子类各自实现，并返回不同的对象。
应用：程序运行时，对应的子类调用自己的创建方法
类的角色以及个数：父类:1个 子类:1~n个
类和类关系：继承

抽象工厂模式：
表现：定义抽象工厂类，以及抽象工厂的产品类，可以让用户更加灵活的创建符合设计规范的自己想要的产品
应用：程序运行时，创建由用户提供的工厂的符合设计者规范的用户提供的产品
类的角色以及个数：抽象工厂-> 子工厂 实现， 工厂-> 产品 依赖
类的个数：抽象工厂接口：1个 抽象产品：1个 子类工厂：1~n个 子类产品：1~n个

单例模式：

建造者模式：

原型模式：


结构型模式，
共七种：

适配器模式：
背景：两个已经存在或者完成的系统，需要协作，但接口不一致，源代码不太可以更改
表现：新加一个Adapter类，实现被协作者的接口，Adapter类同时持有客户类的引用，将对被协作者的接口调用转换为客户的调用，以达到协作的目的
应用：程序运行时，将Adapter类的实例传入被协作者，对Adapter实现的接口调用转换为客户的调用
类的角色以及个数：Adapter类：1个，客户类：1个 服务提供类：1个 服务提供接口类：1个
类和类关系：Adapter类 -> 服务提供接口类 实现，Adapter类 -> 客户类 关联（构造方法传入，目的是将对被协作者的接口调用转换为客户的调用）

装饰器模式：
背景：不继承该类的时候，增强该类的功能
表现：新加一个装饰类，实现被增强类的接口，装饰类同时持有被增强类的引用，提供与被增强类的一致的接口，在对应的接口中调用原接口的内容，并增加额外的功能
应用：程序运行时，使用的是装饰类（增强类）
类的角色以及个数：增强类：1个，被增加类：1个，被增强类接口：1个
类和类关系：增强类 -> 增强类的接口 实现，增强类 -> 被增强类 关联

代理模式：
背景：不继承该类的时候，增加额外的校验、验证
表现：新加一个代理类，实现被代理类的接口，代理类同时持有被代理类的引用，提供与被代理类的一致的接口，在对应的接口中调用原接口的内容，并增加额外的校验
应用：程序运行时，使用的是装饰类（增强类）
类的角色以及个数：代理类：1个，被代理类：1个，被代理类接口：1个
类和类关系：代理类 -> 代理类的接口 实现，代理类 -> 被代理类 关联

外观模式：
背景：一个系统有多个组件，很多接口，外观提供额外的接口，将多个接口简化成一个接口，但仍然保留原有的接口
应用：程序运行时，可以使用简化过的接口，也可以使用原接口（内容不变，但提供新的交互方式）
类的角色以及个数：服务提供接口：1个
类和类关系：

桥接模式：

组合模式：

享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

